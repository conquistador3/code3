#include <bits/stdc++.h>
 
using namespace std;
const int n=100005;
struct node{
int a,b,c;};
node tree[4*n];
int  lazy[4*n];
void cons(int ss,int se,int si)
{
    if(ss==se)
    {
        tree[si].a=1;
        tree[si].b=0;
        tree[si].c=0;
    }
    else
    {
        int mid=(ss+se)/2;
        cons(ss,mid,2*si+1);
        cons(mid+1,se,2*si+2);
        tree[si].a=tree[2*si+1].a+tree[2*si+2].a;
        tree[si].b=tree[2*si+1].b+tree[2*si+2].b;
        tree[si].c=tree[2*si+1].c+tree[2*si+2].c;
    }
}
void update(int si, int ss, int se, int us,
                     int ue)
{
    //cout<<si<<"\n";
    if (lazy[si] != 0)
    {
        if(lazy[si]==1)
        {
 
int k=tree[si].a;
        tree[si].a = tree[si].c;
        tree[si].c=tree[si].b;
        tree[si].b=k;
        }
        else if(lazy[si]==2)
        {
            int k=tree[si].a;
        tree[si].a = tree[si].b;
        tree[si].b=tree[si].c;
        tree[si].c=k;
        }
        if (ss != se)
        {
            lazy[si*2 + 1]   = (lazy[si*2+1]+lazy[si])%3;
            lazy[si*2 + 2]   = (lazy[si*2+2]+lazy[si])%3;
        }
 
        lazy[si] = 0;
    }
    if (ss>se || ss>ue || se<us)
        return ;
 
    if (ss>=us && se<=ue)
    {
    int k=tree[si].a;
        tree[si].a = tree[si].c;
        tree[si].c=tree[si].b;
        tree[si].b=k;
        if (ss != se)
        {
            lazy[si*2 + 1]   = (lazy[si*2+1]+1)%3;
            lazy[si*2 + 2]   = (lazy[si*2+2]+1)%3;
        }
        return;
    }
    int mid = (ss+se)/2;
    update(si*2+1, ss, mid, us, ue);
    update(si*2+2, mid+1, se, us, ue);
    tree[si].a = tree[si*2+1].a + tree[si*2+2].a;
    tree[si].b = tree[si*2+1].b + tree[si*2+2].b;
    tree[si].c = tree[si*2+1].c + tree[si*2+2].c;
}
node getSumUtil(int ss, int se, int qs, int qe, int si)
{
 
    if (lazy[si] != 0)
    {
        //cout<<si<<"si\n";
        if(lazy[si]==1)
        {
int k=tree[si].a;
        tree[si].a = tree[si].c;
        tree[si].c=tree[si].b;
        tree[si].b=k;
        }
        else if(lazy[si]==2)
        {
            int k=tree[si].a;
        tree[si].a = tree[si].b;
        tree[si].b=tree[si].c;
        tree[si].c=k;
        }
        if (ss != se)
        {
            lazy[si*2 + 1]   = (lazy[si*2+1]+lazy[si])%3;
            lazy[si*2 + 2]   = (lazy[si*2+2]+lazy[si])%3;
 
        }
        lazy[si] = 0;
    }
    node res;
    res.a=0;res.b=0;res.c=0;
    if (ss>se || ss>qe || se<qs)
        return res;
 
    if (ss>=qs && se<=qe)
        return tree[si];
 
    int mid = (ss + se)/2;
    node left=getSumUtil(ss, mid, qs, qe, 2*si+1);
    node right=getSumUtil(mid+1, se, qs, qe, 2*si+2);
    res.a=left.a+right.a;
    res.b=left.b+right.b;
    res.c=left.c+right.c;
    return res;
 
}
int main()
{
    int n,m,i,j,s,e;
    scanf("%d%d",&n,&m);
    cons(0,n-1,0);
 
    for(i=0;i<m;i++)
    {
        scanf("%d%d%d",&j,&s,&e);
        if(j)
        {
 
            node p=getSumUtil(0,n-1,s,e,0);
 
            printf("%d\n",p.a);
        }
        else
        {
            update(0,0,n-1,s,e);
 
        }
    }
 
    return 0;
}
